-- +goose Up

-- Создание таблицы static
CREATE TABLE IF NOT EXISTS static
(
    id         INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name       TEXT
        CONSTRAINT upload_name_length CHECK (LENGTH(name) <= 255) NOT NULL,
    path       TEXT
        CONSTRAINT upload_path_length CHECK (LENGTH(path) <= 255) NOT NULL,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- Создание таблицы country
CREATE TABLE IF NOT EXISTS country
(
    id   INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT
        CONSTRAINT name_length CHECK (LENGTH(name) <= 64) NOT NULL UNIQUE
);

-- Создание таблицы genre
CREATE TABLE IF NOT EXISTS genre
(
    id   INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT
        CONSTRAINT genre_name_length CHECK (LENGTH(name) <= 32) UNIQUE
);

-- Создание таблицы person
CREATE TABLE IF NOT EXISTS person
(
    id              INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    kinopoisk_id    INT UNIQUE,
    name            TEXT
        CONSTRAINT person_first_name_length CHECK (LENGTH(name) <= 64)   NOT NULL,
    en_name         TEXT
        CONSTRAINT person_last_name_length CHECK (LENGTH(en_name) <= 64) NOT NULL,
    birth_date      TIMESTAMPTZ,
    death_date      TIMESTAMPTZ CHECK (birth_date IS NULL OR death_date > birth_date),
    sex             CHAR(1)
        CONSTRAINT person_gender CHECK (sex = 'M' OR sex = 'F')          NOT NULL,
    height          INT
        CONSTRAINT height_positive CHECK (height > 50),
    photo_upload_id INT,
    created_at      TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at      TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (photo_upload_id) REFERENCES static (id) ON DELETE SET NULL
);

-- Создание таблицы content
CREATE TABLE IF NOT EXISTS content
(
    id                 INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    kinopoisk_id       INT UNIQUE,
    content_type       TEXT
        CONSTRAINT content_type_check CHECK (content_type = 'movie' OR content_type = 'series') NOT NULL,
    title              TEXT
        CONSTRAINT title_length CHECK (LENGTH(title) <= 150)                                    NOT NULL,
    original_title     TEXT
        CONSTRAINT original_title_length CHECK (LENGTH(original_title) <= 150),
    slogan             TEXT
        CONSTRAINT slogan_length CHECK (LENGTH(slogan) <= 150),
    -- т.к. нужно также указывать валюту, то используем TEXT вместо INT
    budget             TEXT
        CONSTRAINT content_budget_positive CHECK (LENGTH(budget) > 2),
    age_restriction    INT
        CONSTRAINT content_age_restriction_not_negative CHECK (age_restriction >= 0)            NOT NULL,
    imdb               DECIMAL(3, 1)
        CONSTRAINT content_imdb CHECK (imdb >= 0 AND imdb <= 10)                                NOT NULL,
    rating             DECIMAL(3, 1) DEFAULT 0
        CONSTRAINT content_rating CHECK (rating >= 0 AND rating <= 10)                          NOT NULL,
    description        TEXT
        CONSTRAINT description_length CHECK (LENGTH(description) <= 10000)                      NOT NULL,
    poster_upload_id   INT,
    trailer_url        TEXT
        CONSTRAINT trailer_url_length CHECK (LENGTH(trailer_url) <= 255),
    backdrop_upload_id INT,
    created_at         TIMESTAMPTZ   DEFAULT CURRENT_TIMESTAMP,
    updated_at         TIMESTAMPTZ   DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (poster_upload_id) REFERENCES static (id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS content_fact
(
    id         INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    content_id INT                                         NOT NULL,
    fact       TEXT
        CONSTRAINT fact_length CHECK (LENGTH(fact) <= 600) NOT NULL,
    FOREIGN KEY (content_id) REFERENCES content (id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS content_image
(
    id         INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    content_id INT                                         NOT NULL,
    static_id  INT NOT NULL,
    FOREIGN KEY (content_id) REFERENCES content (id) ON DELETE CASCADE,
    FOREIGN KEY (static_id) REFERENCES static (id) ON DELETE CASCADE
);

-- Создание таблицы role
CREATE TABLE IF NOT EXISTS role
(
    id      INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name    TEXT
        CONSTRAINT role_name_length CHECK (LENGTH(name) <= 30) UNIQUE       NOT NULL,
    name_en TEXT
        CONSTRAINT role_name_en_length CHECK (LENGTH(name_en) <= 30) UNIQUE NOT NULL
);


-- Создание таблицы person_role
CREATE TABLE IF NOT EXISTS person_role
(
    id         INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    role_id    INT NOT NULL,
    person_id  INT NOT NULL,
    content_id INT NOT NULL,
    FOREIGN KEY (role_id) REFERENCES role (id) ON DELETE CASCADE,
    FOREIGN KEY (person_id) REFERENCES person (id) ON DELETE CASCADE,
    FOREIGN KEY (content_id) REFERENCES content (id) ON DELETE CASCADE,
    CONSTRAINT role_unique UNIQUE (person_id, content_id, role_id)
);

-- Создание таблицы movie
CREATE TABLE IF NOT EXISTS movie
(
    id         INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    content_id INT NOT NULL UNIQUE,
    premiere   TIMESTAMPTZ,
    duration   INT CHECK (duration > 0),
    FOREIGN KEY (content_id) REFERENCES content (id) ON DELETE CASCADE
);

-- Создание таблицы series
CREATE TABLE IF NOT EXISTS series
(
    id         INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    year_start INT
        CONSTRAINT series_year_start_positive CHECK (year_start > 0) NOT NULL,
    year_end   INT CHECK (year_end >= year_start)
        CONSTRAINT series_year_end_positive CHECK (year_end > 0),
    content_id INT                                                   NOT NULL,
    FOREIGN KEY (content_id) REFERENCES content (id) ON DELETE CASCADE
);

-- Создание таблицы season
CREATE TABLE IF NOT EXISTS season
(
    id        INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title     TEXT
        CONSTRAINT episode_title_length CHECK (LENGTH(title) <= 150) NOT NULL,
    series_id INT                                                    NOT NULL,
    FOREIGN KEY (series_id) REFERENCES series (id) ON DELETE CASCADE
);

-- Создание таблицы episode
CREATE TABLE IF NOT EXISTS episode
(
    id             INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    season_id      INT                                                        NOT NULL,
    episode_number INT
        CONSTRAINT episode_episode_number_positive CHECK (episode_number >= 0) NOT NULL,
    title          TEXT
        CONSTRAINT episode_title_length CHECK (LENGTH(title) <= 150)          NOT NULL,
    duration       INT CHECK (duration > 0),
    FOREIGN KEY (season_id) REFERENCES season (id) ON DELETE CASCADE
);

-- Создание таблицы users
CREATE TABLE IF NOT EXISTS "user"
(
    id               INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name             TEXT
        CONSTRAINT user_name_length CHECK (LENGTH(name) <= 30),
    email            TEXT
        CONSTRAINT email_length CHECK (LENGTH(email) <= 256) UNIQUE                   NOT NULL,
    password_hashed  bytea
        CONSTRAINT password_hashed_length CHECK (OCTET_LENGTH(password_hashed) <= 32) NOT NULL,
    salt_password    bytea
        CONSTRAINT salt_password_length CHECK (OCTET_LENGTH(salt_password) <= 8)      NOT NULL,
    avatar_upload_id INT,
    rating           INT         DEFAULT 0,
    created_at       TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at       TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (avatar_upload_id) REFERENCES static (id) ON DELETE SET NULL
);

-- Создание таблицы review
CREATE TABLE IF NOT EXISTS review
(
    id             INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id        INT                                                                       NOT NULL,
    content_id     INT                                                                       NOT NULL,
    title          TEXT
        CONSTRAINT review_title_length CHECK (LENGTH(title) > 0 AND LENGTH(title) <= 50)     NOT NULL,
    text           TEXT
        CONSTRAINT review_text_length CHECK (LENGTH(text) > 0 AND LENGTH(text) <= 10000)     NOT NULL,
    content_rating INT
        CONSTRAINT rating_user_positive CHECK (content_rating >= 1 AND content_rating <= 10) NOT NULL,
    rating         INT         DEFAULT 0
        CONSTRAINT rating_positive CHECK (rating >= 0),
    likes          INT         DEFAULT 0
        CONSTRAINT likes_positive CHECK (likes >= 0),
    dislikes       INT         DEFAULT 0
        CONSTRAINT dislikes_positive CHECK (dislikes >= 0),
    created_at     TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at     TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES "user" (id) ON DELETE CASCADE,
    FOREIGN KEY (content_id) REFERENCES content (id) ON DELETE CASCADE,
    CONSTRAINT user_content_unique UNIQUE (user_id, content_id)
);

-- Создание таблицы compilation_type
CREATE TABLE IF NOT EXISTS compilation_type
(
    id   INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    type TEXT
        CONSTRAINT compilation_type_length CHECK (LENGTH(type) <= 30) UNIQUE NOT NULL
);

-- Создание таблицы compilation
CREATE TABLE IF NOT EXISTS compilation
(
    id                  INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title               TEXT
        CONSTRAINT compilation_title_length CHECK (LENGTH(title) > 0 AND LENGTH(title) <= 100) NOT NULL,
    compilation_type_id INT
        CONSTRAINT compilation_type_id_positive CHECK (compilation_type_id > 0)               NOT NULL,
    poster_upload_id    INT,
    FOREIGN KEY (poster_upload_id) REFERENCES static (id) ON DELETE CASCADE,
    FOREIGN KEY (compilation_type_id) REFERENCES compilation_type (id) ON DELETE CASCADE,
    CONSTRAINT compilation_type_unique UNIQUE (id, compilation_type_id)
);

-- Создание таблицы compilation_content
CREATE TABLE IF NOT EXISTS compilation_content
(
    compilation_id INT NOT NULL,
    content_id     INT NOT NULL,
    FOREIGN KEY (compilation_id) REFERENCES compilation (id) ON DELETE CASCADE,
    FOREIGN KEY (content_id) REFERENCES content (id) ON DELETE CASCADE,
    CONSTRAINT compilation_content_unique UNIQUE (compilation_id, content_id)
);

-- Создание таблицы review_vote
CREATE TABLE IF NOT EXISTS review_vote
(
    review_id  INT     NOT NULL,
    user_id    INT     NOT NULL,
    value      BOOLEAN NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (review_id) REFERENCES review (id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES "user" (id) ON DELETE CASCADE,
    CONSTRAINT review_likes_unique UNIQUE (review_id, user_id)
);

-- Создание таблицы genre_content
CREATE TABLE IF NOT EXISTS genre_content
(
    genre_id   INT NOT NULL,
    content_id INT NOT NULL,
    FOREIGN KEY (genre_id) REFERENCES genre (id) ON DELETE CASCADE,
    FOREIGN KEY (content_id) REFERENCES content (id) ON DELETE CASCADE,
    CONSTRAINT genre_content_unique UNIQUE (genre_id, content_id)
);

-- Создание таблицы country_content
CREATE TABLE IF NOT EXISTS country_content
(
    country_id INT NOT NULL,
    content_id INT NOT NULL,
    FOREIGN KEY (country_id) REFERENCES country (id) ON DELETE CASCADE,
    FOREIGN KEY (content_id) REFERENCES content (id) ON DELETE CASCADE,
    CONSTRAINT country_content_unique UNIQUE (country_id, content_id)
);

-- +goose StatementBegin
CREATE OR REPLACE FUNCTION update_updated_at_column()
    RETURNS TRIGGER AS
$$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE 'plpgsql';
-- +goose StatementEnd

-- Добавление триггера к каждой таблице, которая имеет поле updated_at
CREATE TRIGGER update_at_person
    BEFORE UPDATE
    ON person
    FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_at_content
    BEFORE UPDATE
    ON content
    FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_at_users
    BEFORE UPDATE
    ON "user"
    FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_at_review
    BEFORE UPDATE
    ON review
    FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_at_review_like
    BEFORE UPDATE
    ON review_vote
    FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- +goose StatementBegin
-- Триггер для обработки вставки и удаления записей в таблице review_like
CREATE OR REPLACE FUNCTION update_review_likes()
    RETURNS TRIGGER AS
$$
BEGIN
    -- пересчитываем рейтинг отзыва и рейтинг юзера, который оставил отзыв
    IF TG_OP = 'INSERT' THEN
        IF NEW.value = TRUE THEN
            UPDATE review
            SET likes  = likes + 1,
                rating = rating + 1
            WHERE id = NEW.review_id;
            UPDATE "user"
            SET rating = rating + 1
            WHERE id = (SELECT user_id FROM review WHERE id = NEW.review_id);
        ELSE
            UPDATE review
            SET dislikes = dislikes + 1,
                rating   = rating - 1
            WHERE id = NEW.review_id;
            UPDATE "user"
            SET rating = rating - 1
            WHERE id = (SELECT user_id FROM review WHERE id = NEW.review_id);
        END IF;
    ELSIF TG_OP = 'DELETE' THEN
        IF OLD.value = TRUE THEN
            UPDATE review
            SET likes  = likes - 1,
                rating = rating - 1
            WHERE id = OLD.review_id;
            UPDATE "user"
            SET rating = rating - 1
            WHERE id = (SELECT user_id FROM review WHERE id = OLD.review_id);
        ELSE
            UPDATE review
            SET dislikes = dislikes - 1,
                rating   = rating + 1
            WHERE id = OLD.review_id;
            UPDATE "user"
            SET rating = rating + 1
            WHERE id = (SELECT user_id FROM review WHERE id = OLD.review_id);
        END IF;
    ELSEIF TG_OP = 'UPDATE' THEN
        IF OLD.value = TRUE AND NEW.value = FALSE THEN
            UPDATE review
            SET likes    = likes - 1,
                dislikes = dislikes + 1,
                rating   = rating - 2
            WHERE id = NEW.review_id;
            UPDATE "user"
            SET rating = rating - 2
            WHERE id = (SELECT user_id FROM review WHERE id = NEW.review_id);
        ELSIF OLD.value = FALSE AND NEW.value = TRUE THEN
            UPDATE review
            SET likes    = likes + 1,
                dislikes = dislikes - 1,
                rating   = rating + 2
            WHERE id = NEW.review_id;
            UPDATE "user"
            SET rating = rating + 2
            WHERE id = (SELECT user_id FROM review WHERE id = NEW.review_id);
        END IF;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE 'plpgsql';
-- +goose StatementEnd

CREATE TRIGGER update_likes
    AFTER INSERT OR DELETE OR UPDATE
    ON review_vote
    FOR EACH ROW
EXECUTE FUNCTION update_review_likes();


-- +goose StatementBegin
-- Триггер для обработки вставки, редактирования и удаления записей в таблице review
CREATE OR REPLACE FUNCTION update_content_rating()
    RETURNS TRIGGER AS
$$
BEGIN
    -- пересчитываем рейтинг контента по 10 балльной шкале
    -- операция затратная, но рецензии оставляют сравнительно редко, так что будем считать это допустимым
    UPDATE content
    SET rating = (SELECT AVG(content_rating) FROM review WHERE content_id = NEW.content_id)
    WHERE id = NEW.content_id;
    RETURN NULL;
END;
$$ LANGUAGE 'plpgsql';
-- +goose StatementEnd

CREATE TRIGGER update_content_rating
    AFTER INSERT OR DELETE OR UPDATE
    ON review
    FOR EACH ROW
EXECUTE FUNCTION update_content_rating();
